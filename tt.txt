from fastapi import APIRouter
import os
import cv2
import time
import torch
import threading

# ---------------------------------------------------------
# FastAPI Router setup
# ---------------------------------------------------------
router = APIRouter()

# ---------------------------------------------------------
# Safe GPIO import (works both on Pi and non-Pi systems)
# ---------------------------------------------------------
try:
    import RPi.GPIO as GPIO
    HARDWARE_AVAILABLE = True
    print("‚úÖ RPi.GPIO successfully imported ‚Äî hardware mode enabled.")
except (ImportError, RuntimeError):
    HARDWARE_AVAILABLE = False
    GPIO = None
    print("‚ö†Ô∏è RPi.GPIO not found ‚Äî running in simulation/mock mode.")

# ---------------------------------------------------------
# Mock GPIO class (for non-Raspberry Pi systems)
# ---------------------------------------------------------
class MockGPIO:
    BCM = "BCM"
    OUT = "OUT"
    IN = "IN"
    HIGH = 1
    LOW = 0

    def setmode(self, mode):
        print(f"[MockGPIO] setmode({mode})")

    def setwarnings(self, flag):
        print(f"[MockGPIO] setwarnings({flag})")

    def setup(self, pin, mode):
        print(f"[MockGPIO] setup(pin={pin}, mode={mode})")

    def output(self, pin, state):
        print(f"[MockGPIO] output(pin={pin}, state={state})")

    def cleanup(self):
        print("[MockGPIO] cleanup()")

# ---------------------------------------------------------
# Global instances and constants
# ---------------------------------------------------------
camera_instance = None
model_instance = None
RELAY_PINS = [17, 27, 22]
DETECTION_THREAD = None
DETECTION_RUNNING = False

# ---------------------------------------------------------
# Hardware initialization
# ---------------------------------------------------------
def initialize_hardware():
    global camera_instance, model_instance, GPIO   # <-- Fix: global GPIO

    if HARDWARE_AVAILABLE:
        print("üîß Initializing Raspberry Pi hardware...")
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        for pin in RELAY_PINS:
            GPIO.setup(pin, GPIO.OUT)
            GPIO.output(pin, GPIO.HIGH)
        print("‚úÖ Real GPIO hardware initialized successfully.")
    else:
        print("üß© Using MockGPIO ‚Äî no real hardware detected.")
        GPIO = MockGPIO()
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        for pin in RELAY_PINS:
            GPIO.setup(pin, GPIO.OUT)
            GPIO.output(pin, GPIO.HIGH)
        print("‚úÖ MockGPIO initialized successfully.")

# ---------------------------------------------------------
# Cleanup
# ---------------------------------------------------------
def cleanup_hardware():
    global GPIO
    if GPIO:
        GPIO.cleanup()
        print("üßπ GPIO cleaned up.")

# ---------------------------------------------------------
# Camera & Model setup
# ---------------------------------------------------------
def load_camera_and_model():
    global camera_instance, model_instance
    print("üì∏ Loading camera and YOLO model...")
    try:
        camera_instance = cv2.VideoCapture(0)
        model_instance = torch.hub.load('ultralytics/yolov5', 'yolov5s', pretrained=True)
        print("‚úÖ Camera and model loaded successfully.")
    except Exception as e:
        print(f"‚ùå Failed to load camera/model: {e}")

# ---------------------------------------------------------
# Detection Loop (runs in background thread)
# ---------------------------------------------------------
def detection_loop():
    global DETECTION_RUNNING
    print("üöÄ Starting detection loop...")
    DETECTION_RUNNING = True
    while DETECTION_RUNNING:
        # Simulated detection logic
        print("üß† Detecting...")
        time.sleep(5)
    print("üõë Detection loop stopped.")

# ---------------------------------------------------------
# FastAPI Endpoints
# ---------------------------------------------------------
@router.get("/status")
async def get_status():
    """Returns current smart detection status."""
    return {
        "hardware": "available" if HARDWARE_AVAILABLE else "mock",
        "camera": "initialized" if camera_instance else "not initialized",
        "detection": "running" if DETECTION_RUNNING else "stopped"
    }

@router.post("/initialize")
async def api_initialize():
    """Initialize hardware and model."""
    initialize_hardware()
    load_camera_and_model()
    return {"message": "Hardware and model initialized successfully"}

@router.post("/start")
async def start_detection():
    """Start the detection loop."""
    global DETECTION_THREAD, DETECTION_RUNNING
    if DETECTION_RUNNING:
        return {"message": "Detection already running"}

    DETECTION_THREAD = threading.Thread(target=detection_loop, daemon=True)
    DETECTION_THREAD.start()
    return {"message": "Detection started"}

@router.post("/stop")
async def stop_detection():
    """Stop the detection loop."""
    global DETECTION_RUNNING
    DETECTION_RUNNING = False
    return {"message": "Detection stopped"}

@router.post("/cleanup")
async def api_cleanup():
    """Clean up GPIO and resources."""
    cleanup_hardware()
    return {"message": "GPIO cleaned up"}

# ---------------------------------------------------------
# Direct run (optional)
# ---------------------------------------------------------
if __name__ == "__main__":
    initialize_hardware()
    load_camera_and_model()
    t = threading.Thread(target=detection_loop, daemon=True)
    t.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        DETECTION_RUNNING = False
        cleanup_hardware()
        print("üõë Program stopped safely.")
