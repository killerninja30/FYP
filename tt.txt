from fastapi import APIRouter
from pydantic import BaseModel
from typing import List, Tuple
import threading
import time

# -----------------------
# Router
# -----------------------
router = APIRouter()

# -----------------------
# Mock GPIO for testing
# -----------------------
class MockGPIO:
    BCM = "BCM"
    OUT = "OUT"
    HIGH = 1
    LOW = 0

    def __init__(self):
        self.states = {}

    def setmode(self, mode):
        print(f"[MockGPIO] setmode({mode})")

    def setwarnings(self, flag):
        pass

    def setup(self, pin, mode):
        self.states[pin] = "OFF"
        print(f"[GPIO] setup pin {pin}")

    def output(self, pin, state):
        self.states[pin] = "ON" if state == self.LOW else "OFF"
        print(f"[GPIO] Pin {pin} -> {self.states[pin]}")

    def cleanup(self):
        print("[GPIO] cleanup")
        self.states.clear()

# -----------------------
# Globals
# -----------------------
HARDWARE_AVAILABLE = False
GPIO = MockGPIO()
RELAY_PINS = [2, 3, 4, 17]
DETECTION_RUNNING = False
DETECTION_THREAD = None
DETECTION_LOCK = threading.Lock()

# -----------------------
# Relay & Appliance Mapping
# -----------------------
APPLIANCE_MAP = {
    2: "Light 1",
    3: "Light 2",
    4: "Fan 1",
    17: "Fan 2"
}

# -----------------------
# Schemas
# -----------------------
class CommandResult(BaseModel):
    relay_id: int
    status: str
    appliance: str

class DetectionResponse(BaseModel):
    detection_running: bool
    relays: dict
    commands: List[CommandResult]

# -----------------------
# Hardware Init/Cleanup
# -----------------------
def initialize_hardware():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    for pin in RELAY_PINS:
        GPIO.setup(pin, GPIO.OUT)
        GPIO.output(pin, GPIO.HIGH)
    print("? Hardware initialized (mock)")

def cleanup_hardware():
    GPIO.cleanup()
    print("?? GPIO cleaned up")

# -----------------------
# Detection Loop
# -----------------------
def detection_loop():
    global DETECTION_RUNNING
    DETECTION_RUNNING = True
    while DETECTION_RUNNING:
        with DETECTION_LOCK:
            # Toggle all relays ON/OFF for demo
            for pin in RELAY_PINS:
                GPIO.output(pin, GPIO.LOW)
            print(f"[DETECTION] Relay states: {GPIO.states}")
            time.sleep(2)
            for pin in RELAY_PINS:
                GPIO.output(pin, GPIO.HIGH)
            time.sleep(2)
    print("?? Detection stopped")

# -----------------------
# Endpoints
# -----------------------
@router.post("/initialize")
def start_hardware():
    initialize_hardware()
    return {"message": "Hardware initialized"}

@router.post("/cleanup")
def cleanup():
    cleanup_hardware()
    return {"message": "Hardware cleaned up"}

@router.post("/start")
def start_detection():
    global DETECTION_THREAD, DETECTION_RUNNING
    if DETECTION_RUNNING:
        return {"message": "Detection already running"}
    DETECTION_THREAD = threading.Thread(target=detection_loop, daemon=True)
    DETECTION_THREAD.start()
    return {"message": "Detection started"}

@router.post("/stop")
def stop_detection():
    global DETECTION_RUNNING
    DETECTION_RUNNING = False
    return {"message": "Detection stopped"}

@router.get("/status")
def status():
    return {
        "hardware": "mock",
        "detection_running": DETECTION_RUNNING,
        "relays": GPIO.states
    }

# -----------------------
# New endpoints for frontend compatibility
# -----------------------
@router.get("/relay-status")
def relay_status():
    return {"relays": GPIO.states}

@router.post("/manual-control/{relay_id}/{action}")
def manual_control(relay_id: int, action: str):
    if relay_id not in RELAY_PINS:
        return {"error": "Invalid relay ID"}
    if action.lower() == "on":
        GPIO.output(relay_id, GPIO.LOW)
    elif action.lower() == "off":
        GPIO.output(relay_id, GPIO.HIGH)
    else:
        return {"error": "Invalid action"}
    return {"message": f"Relay {relay_id} turned {action.upper()}"}

@router.post("/emergency-stop")
def emergency_stop():
    global DETECTION_RUNNING
    DETECTION_RUNNING = False
    for pin in RELAY_PINS:
        GPIO.output(pin, GPIO.HIGH)
    return {"message": "Emergency stop activated. All relays turned OFF"}

@router.post("/detect", response_model=DetectionResponse)
def detect():
    with DETECTION_LOCK:
        commands = []
        for pin in RELAY_PINS:
            status = GPIO.states.get(pin, "OFF")
            commands.append(CommandResult(relay_id=pin, status=status, appliance=APPLIANCE_MAP.get(pin, "Unknown")))
    return DetectionResponse(
        detection_running=DETECTION_RUNNING,
        relays=GPIO.states,
        commands=commands
    )

@router.get("/alerts")
def alerts():
    # Mock alerts
    return {"alerts": ["No motion detected", "Temperature normal"]}

@router.get("/analytics")
def analytics():
    # Mock analytics data
    return {"energy_savings": "12%", "uptime": "98%", "last_active": "2 mins ago"}
