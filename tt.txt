from fastapi import APIRouter
from pydantic import BaseModel
from typing import List, Tuple
import threading
import time
import random

router = APIRouter()

# -----------------------
# Mock GPIO
# -----------------------
class MockGPIO:
    BCM = "BCM"
    OUT = "OUT"
    HIGH = 1
    LOW = 0

    def __init__(self):
        self.states = {}

    def setmode(self, mode):
        print(f"[MockGPIO] setmode({mode})")

    def setwarnings(self, flag):
        pass

    def setup(self, pin, mode):
        self.states[pin] = "OFF"
        print(f"[GPIO] setup pin {pin}")

    def output(self, pin, state):
        self.states[pin] = "ON" if state == self.LOW else "OFF"
        print(f"[GPIO] Pin {pin} -> {self.states[pin]}")

    def cleanup(self):
        print("[GPIO] cleanup")
        self.states.clear()

# -----------------------
# Globals
# -----------------------
GPIO = MockGPIO()
RELAY_PINS = [2, 3, 4, 17]
DETECTION_RUNNING = False
DETECTION_THREAD = None
DETECTION_LOCK = threading.Lock()

APPLIANCE_MAP = {
    2: "Light 1",
    3: "Light 2",
    4: "Fan 1",
    17: "Fan 2"
}

# -----------------------
# Schemas
# -----------------------
class CommandResult(BaseModel):
    relay_id: int
    status: str
    appliance: str

class DetectionResponse(BaseModel):
    detection_running: bool
    relays: dict
    commands: List[CommandResult]

# -----------------------
# Hardware Init / Cleanup
# -----------------------
def initialize_hardware():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    for pin in RELAY_PINS:
        GPIO.setup(pin, GPIO.OUT)
        GPIO.output(pin, GPIO.HIGH)
    print("? Hardware initialized (mock)")

def cleanup_hardware():
    GPIO.cleanup()
    print("?? GPIO cleaned up")

# -----------------------
# Background Detection Loop
# -----------------------
def mock_human_detection_scan():
    """Simulates a 5-second human detection scan every 1 minute"""
    global DETECTION_RUNNING
    DETECTION_RUNNING = True
    while DETECTION_RUNNING:
        print("ðŸ•’ Starting 5-second detection scan...")
        start_time = time.time()
        detected_relays = []

        while time.time() - start_time < 5:
            with DETECTION_LOCK:
                # Randomly toggle relays to simulate detection
                for pin in RELAY_PINS:
                    if random.random() > 0.5:
                        GPIO.output(pin, GPIO.LOW)  # ON
                        detected_relays.append(pin)
                    else:
                        GPIO.output(pin, GPIO.HIGH)  # OFF
            time.sleep(1)  # simulate frame interval

        # Print summary of scan
        with DETECTION_LOCK:
            print(f"[DETECTION RESULT] Relays ON: {detected_relays}")
            print(f"[DETECTION STATE] All relay states: {GPIO.states}")
        
        print("âœ… 5-second detection complete. Waiting 55 seconds until next scan...\n")
        # Wait remaining time to make it 1 minute interval
        for _ in range(55):
            if not DETECTION_RUNNING:
                break
            time.sleep(1)

# -----------------------
# API Endpoints
# -----------------------
@router.post("/initialize")
def start_hardware():
    initialize_hardware()
    return {"message": "Hardware initialized"}

@router.post("/cleanup")
def cleanup():
    global DETECTION_RUNNING
    DETECTION_RUNNING = False
    cleanup_hardware()
    return {"message": "Hardware cleaned up"}

@router.post("/start")
def start_detection():
    global DETECTION_THREAD, DETECTION_RUNNING
    if DETECTION_RUNNING:
        return {"message": "Detection already running"}
    DETECTION_THREAD = threading.Thread(target=mock_human_detection_scan, daemon=True)
    DETECTION_THREAD.start()
    return {"message": "Detection thread started (5-second scan every 1 minute)"}

@router.post("/stop")
def stop_detection():
    global DETECTION_RUNNING
    DETECTION_RUNNING = False
    return {"message": "Detection stopped"}

@router.get("/status")
def status():
    return {
        "hardware": "mock",
        "detection_running": DETECTION_RUNNING,
        "relays": GPIO.states
    }

@router.get("/relay-status")
def relay_status():
    return {"relays": GPIO.states}

@router.post("/manual-control/{relay_id}/{action}")
def manual_control(relay_id: int, action: str):
    if relay_id not in RELAY_PINS:
        return {"error": "Invalid relay ID"}
    if action.lower() == "on":
        GPIO.output(relay_id, GPIO.LOW)
    elif action.lower() == "off":
        GPIO.output(relay_id, GPIO.HIGH)
    else:
        return {"error": "Invalid action"}
    return {"message": f"Relay {relay_id} turned {action.upper()}"}

@router.post("/emergency-stop")
def emergency_stop():
    global DETECTION_RUNNING
    DETECTION_RUNNING = False
    for pin in RELAY_PINS:
        GPIO.output(pin, GPIO.HIGH)
    return {"message": "Emergency stop activated. All relays OFF"}

@router.post("/detect", response_model=DetectionResponse)
def detect():
    # Return current relay states (mock detection snapshot)
    with DETECTION_LOCK:
        commands = [
            CommandResult(
                relay_id=pin,
                status=GPIO.states.get(pin, "OFF"),
                appliance=APPLIANCE_MAP.get(pin, "Unknown")
            )
            for pin in RELAY_PINS
        ]
    return DetectionResponse(
        detection_running=DETECTION_RUNNING,
        relays=GPIO.states,
        commands=commands
    )

@router.get("/alerts")
def alerts():
    return {"alerts": ["No motion detected", "Temperature normal"]}

@router.get("/analytics")
def analytics():
    return {"energy_savings": "12%", "uptime": "98%", "last_active": "2 mins ago"}
